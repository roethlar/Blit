syntax = "proto3";
package blit.v2;

// The main service for all data transfer and remote management operations.
service Blit {
  // Push uses a bidirectional stream for an efficient "check-then-send" workflow.
  rpc Push(stream ClientPushRequest) returns (stream ServerPushResponse);

  // Streams a file or directory from the server to the client.
  // DEPRECATED: Use PullSync for incremental/selective transfers.
  rpc Pull(PullRequest) returns (stream PullChunk);

  // Bidirectional pull with manifest comparison for selective transfers.
  // Client sends local manifest, server compares and sends only needed files.
  rpc PullSync(stream ClientPullMessage) returns (stream ServerPullMessage);

  // Lists contents of a remote directory.
  rpc List(ListRequest) returns (ListResponse);

  // Deletes files/directories on the server for mirror operations.
  rpc Purge(PurgeRequest) returns (PurgeResponse);

  // Provides path completion suggestions for a given remote path prefix.
  rpc CompletePath(CompletionRequest) returns (CompletionResponse);

  // Lists the available modules on the server.
  rpc ListModules(ListModulesRequest) returns (ListModulesResponse);

  // Recursively finds files/directories starting at a module path.
  rpc Find(FindRequest) returns (stream FindEntry);

  // Summarises disk usage for a subtree (du-style).
  rpc DiskUsage(DiskUsageRequest) returns (stream DiskUsageEntry);

  // Reports module/storage capacity information (df-style).
  rpc FilesystemStats(FilesystemStatsRequest) returns (FilesystemStatsResponse);
}

// Optional service for handling authentication if needed in the future.
service BlitAuth {
  rpc Authenticate(AuthRequest) returns (AuthResponse);
}

// --- Message Definitions ---

// Negotiation response indicating how the data plane (TCP/RDMA) is configured.
message DataTransferNegotiation {
  uint32 tcp_port = 1;
  string one_time_token = 2;
  bool tcp_fallback = 3; // true when the server could not reserve the preferred data-plane.
  uint32 stream_count = 4; // number of parallel TCP streams negotiated for the data plane
  reserved 5 to 10; // RDMA fields (QP numbers, GID, etc.) for Phase 3.5
}

// Push Operation
message ClientPushRequest {
  oneof payload {
    PushHeader header = 1;
    FileHeader file_manifest = 2;
    ManifestComplete manifest_complete = 3;
    FileData file_data = 4;
    UploadComplete upload_complete = 5;
    TarShardHeader tar_shard_header = 6;
    TarShardChunk tar_shard_chunk = 7;
    TarShardComplete tar_shard_complete = 8;
  }
}

message ServerPushResponse {
  oneof payload {
    Ack ack = 1;
    FileList files_to_upload = 2; // The "NeedList"
    PushSummary summary = 3;
    DataTransferNegotiation negotiation = 4; // Negotiation event before summary
  }
}

message PushHeader {
  string module = 1;
  bool mirror_mode = 2;
  string destination_path = 3;
  bool force_grpc = 4;
  // Note: Other options like checksum type can be added here.
}

message FileHeader {
  string relative_path = 1;
  uint64 size = 2;
  int64 mtime_seconds = 3;
  uint32 permissions = 4;
  bytes checksum = 5;  // Blake3 hash (32 bytes), empty if not computed
}

message FileData {
  bytes content = 1;
}

message TarShardHeader {
  repeated FileHeader files = 1;
  uint64 archive_size = 2;
}

message TarShardChunk {
  bytes content = 1;
}

message TarShardComplete {}

message ManifestComplete {}
message UploadComplete {}
message Ack {}

// Acknowledgment for PullSync with server capabilities
message PullSyncAck {
  bool server_checksums_enabled = 1;  // Whether daemon computed checksums for manifest
}
message FileList { repeated string relative_paths = 1; }
message PushSummary {
    uint64 files_transferred = 1;
    uint64 bytes_transferred = 2;
    uint64 bytes_zero_copy = 3; // bytes sent via zero-copy kernel paths
    bool tcp_fallback_used = 4; // true if we had to fall back to gRPC streaming
    uint64 entries_deleted = 5; // count of files/dirs removed during mirror purge
}

// Pull Operation
message PullRequest {
  string module = 1;
  string path = 2;
  bool force_grpc = 3;
  bool metadata_only = 4;
}

message PullChunk {
  oneof payload {
    FileHeader file_header = 1;
    FileData file_data = 2;
    DataTransferNegotiation negotiation = 3;
    PullSummary summary = 4;
    ManifestBatch manifest_batch = 5;
  }
}

message ManifestBatch {
  uint64 file_count = 1;
  uint64 total_bytes = 2;
}

message PullSummary {
  uint64 files_transferred = 1;
  uint64 bytes_transferred = 2;
  uint64 bytes_zero_copy = 3;
  bool tcp_fallback_used = 4;
  uint64 entries_deleted = 5; // count of files/dirs removed during mirror purge
}

// PullSync Operation (bidirectional pull with manifest comparison)
message ClientPullMessage {
  oneof payload {
    PullSyncHeader header = 1;           // Initial request with module/path
    FileHeader local_file = 2;           // Client's local file metadata
    ManifestComplete manifest_done = 3;  // Signals end of client manifest
    BlockHashList block_hashes = 4;      // Client's block hashes for resume mode
  }
}

// Block-level resume messages
message BlockHashList {
  string relative_path = 1;              // File this applies to
  uint32 block_size = 2;                 // Size of each block (last may be smaller)
  repeated bytes hashes = 3;             // Blake3 hashes (32 bytes each), in order
}

message BlockTransfer {
  string relative_path = 1;              // File this block belongs to
  uint64 offset = 2;                     // Byte offset in file
  bytes content = 3;                     // Block data
}

message BlockTransferComplete {
  string relative_path = 1;              // File that's now complete
  uint64 total_bytes = 2;                // Final file size (for truncation if needed)
}

message ServerPullMessage {
  oneof payload {
    Ack ack = 1;                              // Acknowledgment of header (deprecated, use pull_sync_ack)
    FileList files_to_download = 2;           // The "NeedList" - files client should receive
    DataTransferNegotiation negotiation = 3;  // Data plane setup
    PullSummary summary = 4;                  // Final summary
    ManifestBatch manifest_batch = 5;         // Progress: server discovered X files
    FileHeader file_header = 6;               // For gRPC fallback: file being sent
    FileData file_data = 7;                   // For gRPC fallback: file content
    PullSyncAck pull_sync_ack = 8;            // Acknowledgment with server capabilities
    BlockHashRequest block_hash_request = 9;  // Server requests block hashes for resume
    BlockTransfer block_transfer = 10;        // Server sends a block for resume
    BlockTransferComplete block_complete = 11; // Server signals file resume complete
  }
}

// Server requests block hashes from client for a file it wants to resume
message BlockHashRequest {
  string relative_path = 1;              // File to get block hashes for
  uint32 block_size = 2;                 // Block size to use
}

message PullSyncHeader {
  string module = 1;
  string path = 2;
  bool force_grpc = 3;
  bool mirror_mode = 4;  // If true, client wants deletions reported
  // Comparison options
  bool size_only = 5;       // Compare only by size, ignore mtime
  bool ignore_times = 6;    // Transfer all files unconditionally
  bool ignore_existing = 7; // Skip files that already exist on target
  bool force = 8;           // Overwrite even if target is newer (dangerous)
  bool checksum = 9;        // Force checksum comparison (slower but more accurate)
  bool resume = 10;         // Enable block-level resume for partial/changed files
  uint32 block_size = 11;   // Block size for resume (0 = default 1 MiB)
}

// Other Operations
message ListRequest { string module = 1; string path = 2; }
message ListResponse { repeated FileInfo entries = 1; }
message FileInfo {
  string name = 1;
  bool is_dir = 2;
  uint64 size = 3;
  int64 mtime_seconds = 4;
}

message PurgeRequest { string module = 1; repeated string paths_to_delete = 2; }
message PurgeResponse { uint64 files_deleted = 1; }

message CompletionRequest {
  string module = 1;
  string path_prefix = 2;
  bool include_files = 3;
  bool include_directories = 4;
}
message CompletionResponse { repeated string completions = 1; }

message ListModulesRequest {}
message ListModulesResponse { repeated ModuleInfo modules = 1; }
message ModuleInfo {
    string name = 1;
    string path = 2;
    bool read_only = 3;
}

message FindRequest {
  string module = 1;
  string start_path = 2;
  string pattern = 3;
  bool case_sensitive = 4;
  bool include_files = 5;
  bool include_directories = 6;
  uint32 max_results = 7;
}

message FindEntry {
  string relative_path = 1;
  bool is_dir = 2;
  uint64 size = 3;
  int64 mtime_seconds = 4;
}

message DiskUsageRequest {
  string module = 1;
  string start_path = 2;
  uint32 max_depth = 3;
}

message DiskUsageEntry {
  string relative_path = 1;
  uint64 byte_total = 2;
  uint64 file_count = 3;
  uint64 dir_count = 4;
}

message FilesystemStatsRequest {
  string module = 1;
}

message FilesystemStatsResponse {
  string module = 1;
  uint64 total_bytes = 2;
  uint64 used_bytes = 3;
  uint64 free_bytes = 4;
}

message AuthRequest { string token = 1; }
message AuthResponse { bool authenticated = 1; }
