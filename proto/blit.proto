syntax = "proto3";
package blit.v2;

// The main service for all data transfer and remote management operations.
service Blit {
  // Push uses a bidirectional stream for an efficient "check-then-send" workflow.
  rpc Push(stream ClientPushRequest) returns (stream ServerPushResponse);

  // Streams a file or directory from the server to the client.
  rpc Pull(PullRequest) returns (stream PullChunk);

  // Lists contents of a remote directory.
  rpc List(ListRequest) returns (ListResponse);

  // Deletes files/directories on the server for mirror operations.
  rpc Purge(PurgeRequest) returns (PurgeResponse);

  // Provides path completion suggestions for a given remote path prefix.
  rpc CompletePath(CompletionRequest) returns (CompletionResponse);

  // Lists the available modules on the server.
  rpc ListModules(ListModulesRequest) returns (ListModulesResponse);

  // Recursively finds files/directories starting at a module path.
  rpc Find(FindRequest) returns (stream FindEntry);

  // Summarises disk usage for a subtree (du-style).
  rpc DiskUsage(DiskUsageRequest) returns (stream DiskUsageEntry);

  // Reports module/storage capacity information (df-style).
  rpc FilesystemStats(FilesystemStatsRequest) returns (FilesystemStatsResponse);
}

// Optional service for handling authentication if needed in the future.
service BlitAuth {
  rpc Authenticate(AuthRequest) returns (AuthResponse);
}

// --- Message Definitions ---

// Negotiation response indicating how the data plane (TCP/RDMA) is configured.
message DataTransferNegotiation {
  uint32 tcp_port = 1;
  string one_time_token = 2;
  bool tcp_fallback = 3; // true when the server could not reserve the preferred data-plane.
  uint32 stream_count = 4; // number of parallel TCP streams negotiated for the data plane
  reserved 5 to 10; // RDMA fields (QP numbers, GID, etc.) for Phase 3.5
}

// Push Operation
message ClientPushRequest {
  oneof payload {
    PushHeader header = 1;
    FileHeader file_manifest = 2;
    ManifestComplete manifest_complete = 3;
    FileData file_data = 4;
    UploadComplete upload_complete = 5;
    TarShardHeader tar_shard_header = 6;
    TarShardChunk tar_shard_chunk = 7;
    TarShardComplete tar_shard_complete = 8;
  }
}

message ServerPushResponse {
  oneof payload {
    Ack ack = 1;
    FileList files_to_upload = 2; // The "NeedList"
    PushSummary summary = 3;
    DataTransferNegotiation negotiation = 4; // Negotiation event before summary
  }
}

message PushHeader {
  string module = 1;
  bool mirror_mode = 2;
  string destination_path = 3;
  bool force_grpc = 4;
  // Note: Other options like checksum type can be added here.
}

message FileHeader {
  string relative_path = 1;
  uint64 size = 2;
  int64 mtime_seconds = 3;
  uint32 permissions = 4;
}

message FileData {
  bytes content = 1;
}

message TarShardHeader {
  repeated FileHeader files = 1;
  uint64 archive_size = 2;
}

message TarShardChunk {
  bytes content = 1;
}

message TarShardComplete {}

message ManifestComplete {}
message UploadComplete {}
message Ack {}
message FileList { repeated string relative_paths = 1; }
message PushSummary {
    uint64 files_transferred = 1;
    uint64 bytes_transferred = 2;
    uint64 bytes_zero_copy = 3; // bytes sent via zero-copy kernel paths
    bool tcp_fallback_used = 4; // true if we had to fall back to gRPC streaming
    uint64 entries_deleted = 5; // count of files/dirs removed during mirror purge
}

// Pull Operation
message PullRequest {
  string module = 1;
  string path = 2;
  bool force_grpc = 3;
}

message PullChunk {
  oneof payload {
    FileHeader file_header = 1;
    FileData file_data = 2;
    DataTransferNegotiation negotiation = 3;
    PullSummary summary = 4;
  }
}

message PullSummary {
  uint64 files_transferred = 1;
  uint64 bytes_transferred = 2;
  uint64 bytes_zero_copy = 3;
  bool tcp_fallback_used = 4;
}

// Other Operations
message ListRequest { string module = 1; string path = 2; }
message ListResponse { repeated FileInfo entries = 1; }
message FileInfo {
  string name = 1;
  bool is_dir = 2;
  uint64 size = 3;
  int64 mtime_seconds = 4;
}

message PurgeRequest { string module = 1; repeated string paths_to_delete = 2; }
message PurgeResponse { uint64 files_deleted = 1; }

message CompletionRequest {
  string module = 1;
  string path_prefix = 2;
  bool include_files = 3;
  bool include_directories = 4;
}
message CompletionResponse { repeated string completions = 1; }

message ListModulesRequest {}
message ListModulesResponse { repeated ModuleInfo modules = 1; }
message ModuleInfo {
    string name = 1;
    string path = 2;
    bool read_only = 3;
}

message FindRequest {
  string module = 1;
  string start_path = 2;
  string pattern = 3;
  bool case_sensitive = 4;
  bool include_files = 5;
  bool include_directories = 6;
  uint32 max_results = 7;
}

message FindEntry {
  string relative_path = 1;
  bool is_dir = 2;
  uint64 size = 3;
  int64 mtime_seconds = 4;
}

message DiskUsageRequest {
  string module = 1;
  string start_path = 2;
  uint32 max_depth = 3;
}

message DiskUsageEntry {
  string relative_path = 1;
  uint64 byte_total = 2;
  uint64 file_count = 3;
  uint64 dir_count = 4;
}

message FilesystemStatsRequest {
  string module = 1;
}

message FilesystemStatsResponse {
  string module = 1;
  uint64 total_bytes = 2;
  uint64 used_bytes = 3;
  uint64 free_bytes = 4;
}

message AuthRequest { string token = 1; }
message AuthResponse { bool authenticated = 1; }
